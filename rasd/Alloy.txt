module util/boolean
module util/integer


sig Name, Surname, Addr{}
sig Email, Password, PIN{}
sig PaymentMethod


sig RegisteredUser{
        name: some Name,
        surname: some Surname,
        address: one Addr,
        email: one Email -> one Password,
        pin: one PIN,
        suspended: one Bool,
        paymentMethod: one PaymentMethod
        reservations: set Reservation
}


//A reservation is considered active from its creation until its termination
sig Reservation{
        reservedCar: one Car
        requestUnlock: set requestUnlock //user can make or different requests
        active: one Bool
        destination: one GPS
        }


sig GPS{
coordinateX: one Int //Alloy doesn’t support Float
coordinateY: one Int
insideCity: one Bool
}


sig UnlockRequest{
correctUserPosition: one Bool  
unlockOutcome: one Bool //the request can have a positive or negative outcome
}


sig Car{
        position: one GPS,
        available: one Bool
        InMaintenance : one Bool,
        reserved: one Bool,
        reservation : set Reservation
        locked: one Bool,
        batteryPercentage: one Int
        inCharge: one Bool
}


//Two different users can’t have the same email
fact NoSameEmailForDifferentUsers{
        no disjoint u1, u2 : User | u1.email = u2.email
}


//Two different users can’t have the same PIN
fact NoSamePINForDifferentUsers{
        no disjoint u1, u2 : User | u1.pin = u2.pin
}


//If a car is reserved, the car can’t be in maintenance or availble to other users.
fact carStatus {
        all c: Car | c.available = True implies (c.reserved = False and c.inMaintenance = 
False)
}


fact NoMultipleActiveReservationOnSameCar {
        no disjoint r1, r2: Reservation, all c : Car | r1 in c.reservation and r2 in 
c.reservation and and r1.active = True and r2.active = True
}


fact NoMultipleActiveReservationForSameUser{
        no disjoint r1, r2: Reservation, all u1: User | r1 in u1.reservation and r2 in
u1.reservation and r1.active = True and r2.active = True
}


//If a user is suspended, none of his reservation is active
fact userSuspended {
        all u: User, all r: Reservation | (u. suspended = True and r in u.reservations) implies
r.active = False
}


//The unlock request is successful only when the user is close enough to the car and //viceversa
fact unlockRequestOutcome {
        all u: UnlockRequest | u1.unlockOutcome = True iff u1.correctUserPosition = True
}


pred  checkEndedReservation [r: Reservation]
        r.active = False implies 




sig SafeArea {
        coordinates: one GPS,
        numberOfSpots: some Int,
        availableSpots: some Int,
        powerGrid: one Bool
}


fact totalAvailableSpots  {
        all a: SafeArea | #a.availableSpots <= #a.numberOfSpots
}


//When a car is available, it is locked in a safe area
fact availableCarPosition [a: SafeArea, c: Car]
        c.available = True implies (c.locked = True and c.position = a.coordinates)


//Safe areas are located at different locations
fact safeAreasDifferentLocation {
all disjoint a1, a2 : SafeArea | a1.coordinates != a2.coordinates
}


fact safeAreaInsideCity {
        all c: Car | c.coordintaes.insideCity = True
}






asserts allowReservationOfAvailableCars {
        all u: User, all r: Reservation | (r.active = True and r in u.reservations) implies 
(r.reservedCar.available = False and r.reservedCar.InMaintenance = False and
r.reservedCar.reserved = True and r.reservedCar.reservation = r)
}


Differenza tra fact e predicates -> fact proprietà che sono sempre vere nel modello, predicates proprietà che voglio verificare