module util/boolean
module util/integer


sig Name, Surname, Addr{}
sig Email, Password, PIN{}


sig RegisteredUser{
        name: some Name,
        surname: some Surname,
        address: one Addr,
        email: one Email -> one Password,
        pin: one PIN,
        suspended: one Bool,
        reservation: set Reservation
}


sig Reservation{
        uniqueID: one Int
        moment: one Moment
        reservedCar: one Car
        requestUnlock: set requestUnlock //user can make or not different car unlock //requests
        active: one Bool
        destination: one GPS
        }


sig Moment{
        seconds: Int
        minutes: Int, 
        hours: Int
}


sig GPS{
coordinateX: one Int //Alloy doesn’t support Float
coordinateY: one Int
insideCity: one Bool
}


sig UnlockRequest{
correctUserPosition: one Bool  
unlockOutcome: one Bool //the request can have a positive or negative outcome
}














sig Car{
        position: one GPS,
        available: one Bool
        InMaintenance : one Bool,
        reserved: one Bool,
        reservation : set Reservation
        locked: one Bool,
        batteryPercentage: one Int
        inCharge: one Bool
}


//Two different users can’t have the same email
pred NoSameEmailForDifferentUsers[u1: User, u2: User]{
        u1.email != u2.email
}


//Two different users can’t have the same PIN
pred NoSamePINForDifferentUsers[u1: User, u2: User]{
        u1.pin != u2.pin
}


//If a car is reserved, the car can’t be in maintenance or availble to other users.
pred AllowReservationOfAvailableCars [u1: User, r1: Reservation, c: Car] {
        u1.reservation != none and r1.active = True implies 
(c.available = False and c.InMaintenance = False and
c.reserved = True and c.currentReservation = r1)
}


pred NoMultipleActiveReservationOnSameCar[c: Car]
        
}


fun getCarActiveReservation(c: Car) : Reservation {
        res: Reservation | res.active = True
}


pred NoMultipleActiveReservation[u1: User] {
        #getActiveReservation(u1) = 1
}


fun getUserActiveReservation(u: User) : Reservation {
        res: Reservation | res.active = True
}




//The unlock request is successful only when the user is close enough to the car and //viceversa
pred checkUnlockRequest[u1: UnlockRequest] {
        u1.unlockOutcome = True iff u1.correctUserPosition = True


pred  checkEndedReservation [r: Reservation]
        r.active = False implies 




sig SafeArea {
        coordinates: one GPS,
        numberOfSpots: some Int,
        availableSpots: some Int,
        powerGrid: one Bool
}


pred totalAvailableSpots [a: SafeArea] {
        #a.availableSpots <= #a.numberOfSpots
}


//When a car is available, it is locked in a safe area
fact availableCarPosition [a: SafeArea, c: Car]
        c.available = True implies (c.locked = True and c.position = a.coordinates)


//Safe areas are located at different locations
fact safeAreasDifferentLocation {
all disjoint a1, a2 : SafeArea | a1.coordinates != a2.coordinates


PROVARE ALLOY SEQ?