Overview
This section aims to present an overview of the architecture of the system, starting from the main software layers and their interconnections. The description will then focus on the main high-level components of the system. Then the high-level components will be deeply detailed in their sub-components. The end of this section will provide information about the main architectural styles used to design the system, the main design choices made and their rationales.


High level components and their interaction
The system will be constituted by the following high-level components (software layers):
* Database: this layer is responsible for storing and retrieving the persistent data of the PowerEnjoy company. It doesn’t implement any business logic and must guarantee the canonic ACID properties. This layer interacts with the Application Server layer.
* Application server:  the application server software layer implements the whole business logic and its algorithms; it interacts with the database layer and with the web server layer. It also provides a service-oriented interface (RESTful).
* Web server: the web server software layer implements the presentation layer and does not involve any business logic, which is part of the application server.
* Mobile application: the application used by the users and the operators, which runs on an Android or iOS device. It communicates with the application server to access the main logic functionalities of the PowerEnjoy system and with the web server to access some web components.
* Car’s application: Android application running on a car owned by PowerEnjoy; it communicates directly with the application server since the app will be native and there will be no interaction with the presentation layer of the PowerEnjoy Web server.


The system is structured in four logic layers and it can distributed on four different physical locations, therefore implementing a four-tier architecture. The client tier is composed by both the client’s mobile application and the car’s application. 
This design choice is suitable for the PowerEnjoy system: this architecture separates well the business logic and the web presentation, allowing more easily the extension of a layer and thus providing an adequate degree of scalability. In fact, as stated in the RASD, the architecture should be developed having in mind also a future browser version of the S2B to access the PowerEnjoy services and in this case the web presentation layer will become more important. In addition, the logic is mainly located on the server side, so that the client tier doesn’t have to use its resources to implement any complex business logic.


Component View


DATABASE


WEB SERVER
The communication of the system with the cars’ applications and with the clients’ applications is implemented by different components in the web server: the system, in particular, will adopt two different protocols to communicate with the cars and with the mobile application of the clients.


MOBILE APPLICATION
RESTFul, HTTP, Java Faces


POWERENJOY CAR
The common HTTP protocol is not very suitable for handling the communication between the PowerEnjoy cars and the system: usually in the HTTP protocol the server is passive and it is able to send data to the client only in response to a client’s request. In the PowerEnjoy system, though, it is necessary to the application server to request different mecanichal actions without a previous contact from the cars.
The HTTP protocol offers some possible solutions to this issue, such as HTTP push server or HTTP polling, by basically putting the client in a situation of periodically sending requests to server: this tecniques though are pretty expensive in terms of resources and it seems preferable to use another communication protocol, such as the WebSocket protocol.
The WebSocket protocol allows us to create a full-duplex channel of communication between the web server of the system and every car of PowerEnjoy over the TCP protocol; the system can establish a unique and bidirectional stream of requests and information between each car and the web server of the system.
In addition, JEE offers an API for creating a WebSocket component in the web server; it also allows the application server to communicate with the WebSocket endpoint using different features, such as injection of managed beans.




APPLICATION SERVER
The business logic of the application server is implemented by stateless Enterprise JavaBeans. Some of this beans implements the RESTful principle and they offer methods to the users’ mobile application, while other beans implement a more internal business logic.


AccountManager
This EJB is responsible for all the operations related to users’ and operators’ accounts. This bean is enough self contained to be easily extended in future with other operations related to account management, like: editing of profile informations and deletion of an account (for users).
-register(email, password, personalData[], paymentInformations[]): String
-login(email, password): String (sessionIdentifier or Error info)
-PINhandler(registeredUserMail): void 
-suspendUser(RegisteredUser): void
-verifyPaymentInformation(paymentInformations[]): String (StripeToken)
-registerOperator(operatorEmail): void (password generata qui dentro, email letta da file di configurazione) 
        






RegisteredUserManager: 
This EJB manages all the functionalities that are available to the users registered to the system, among which: locate all the available cars, reserve an available car, request the unlock of the reserved car. 
-findAvailableCarsByGPS(latitude, longitude): List<Car>
-findAvailableCarsByAddress(address): List<Car>
-reserveCar(CarLicensePlate): String
-unlock(): String
-insertPIN(uniquePIN, latitude, longitude): String


/*Ricordati di inserire nel documento una breve parte in cui parli di Injection e della possibilità di injection of managed beans (tra cui gli EJB e il WebSocket component) grazie al JNDI*/


OperatorManager
This bean provides all the features needed by the operators in order to accomplish their maintenance tasks: obtaining a list of all the unavailable cars; the possibility to setting one of the unavailable cars as under maintenance; the possibility to set the fixed car back to an available state.
-findUnaveilableCars(): List<Car>//add a car attribute about problem
-maintainCar(licencePlate): String
-setCarToAvailable(): String


ReservationManager
This bean manages the features related to the reservation of a car performed by a user.
-terminateReservation(latitude, longitude, ): 
-makeStop():






getCurrentReservation: this method shows the user all the information related to his current reservation, such as the starting time and the reserved car. This method returns a Reservation object or an error message communicating that no active reservation exists.
create




CarManager
This enterprise bean handles all the requests that the system needs to send to the PowerEnjoy cars: by communicating with the WebSocket endpoint in the web server (typically through the managed bean injection feature offered by Java EE) this bean will be able to request any mechanical action of a specified car.
Any modification of a car proprierty will be forwarded to the related entity in the database layer using the Java Persistence API.
Notice that this bean is not directly accessible to the users’ mobile application, and thus it is not implementing the RESTful protocol.
requestUnlock(car Car): this method will send to the WebSocket endpoint in the Web server a request for the unlock of the car: the WebSocket component will forward this request directly to the car and return a boolean outcome of the unlock operation.
setStatus(car Car): this method is used to modify the status of the car passed as parameter, by communicating with the WebSocket endpoint and retrieving the status by the actual car.
setBatteryCharge(car Car): this method is used to update the battery percentage of the car passed as parameter.
getCarPosition:














Deployment View


Runtime View


Component Interfaces


Selected Architectural Styles And Patterns


Other Design Decisions
//in the database we won’t store any payment information detail -> Stripe api