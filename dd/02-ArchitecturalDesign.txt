Overview
This section aims to present an overview of the architecture of the system, starting from the main software layers and their interconnections. The description will then focus on the main high-level components of the system. Then the high-level components will be deeply detailed in their sub-components. The end of this section will provide information about the main architectural styles used to design the system, the main design choices made and their rationales.


High level components and their interaction
The system will be constituted by the following high-level components (software layers):
* Database: this layer is responsible for storing and retrieving the persistent data of the PowerEnjoy company. It doesn’t implement any business logic and must guarantee the canonic ACID properties. This layer interacts with the Application Server layer.
* Application server:  the application server software layer implements the whole business logic and its algorithms; it interacts with the database layer and with the web server layer. It also provides a service-oriented interface (RESTful).
* Web server: the web server software layer implements the presentation layer and does not involve any business logic, which is part of the application server.
* User’s mobile application: the application used by the users and the operators, which runs on an Android or iOS device. It communicates with the application server to access the main logic functionalities of the PowerEnjoy system and with the web server to access some web components.
* Car’s application: Android application running on a car owned by PowerEnjoy; it communicates directly with the application server since the app will be native and there will be no interaction with the presentation layer of the PowerEnjoy Web server.






The system is structured in four logic layers and it can distributed on four different physical locations, therefore implementing a four-tier architecture. The client tier is composed by both the client’s mobile application and the car’s application. 
This design choice is suitable for the PowerEnjoy system: this architecture separates well the business logic and the web presentation, allowing more easily the extension of a layer and thus providing an adequate degree of scalability. In fact, as stated in the RASD, the architecture should be developed having in mind also a future browser version of the S2B to access the PowerEnjoy services and in this case the web presentation layer will become more important. In addition, the logic is mainly located on the server side, so that the client tier doesn’t have to use its resources to implement any complex business logic.


Component View


DATABASE


WEB SERVER
The communication of the system with the cars’ applications and with the clients’ applications is implemented by different components in the web server: the system, in particular, will adopt two different protocols to communicate with the cars and with the mobile application of the clients.


MOBILE APPLICATION
RESTFul, HTTP, Java Faces


POWERENJOY CAR
The common HTTP protocol is not very suitable for handling the communication between the PowerEnjoy cars and the system: usually in the HTTP protocol the server is passive and it is able to send data to the client only in response to a client’s request. In the PowerEnjoy system, though, it is necessary to the application server to request different mecanichal actions without a previous contact from the cars.
The HTTP protocol offers some possible solutions to this issue, such as HTTP push server or HTTP polling, by basically putting the client in a situation of periodically sending requests to server: this tecniques though are pretty expensive in terms of resources and it seems preferable to use another communication protocol, such as the WebSocket protocol.
The WebSocket protocol allows us to create a full-duplex channel of communication between the web server of the system and every car of PowerEnjoy over the TCP protocol; the system can establish a unique and bidirectional stream of requests and information between each car and the web server of the system.
In addition, JEE offers an API for creating a WebSocket component in the web server; it also allows the application server to communicate with the WebSocket endpoint using different features, such as  injection of managed beans.




APPLICATION SERVER


The business logic of the application server is implemented by stateless Enterprise JavaBeans. Some of this beans implements the RESTful principle and they offer methods to the users’ mobile application, while other beans implement a more internal business logic.


*Lista di possibili beans - difficoltà nel delineare la distinzioni tra i metodi dei beans e i metodi delle classi, non credo siano la stessa cosa: credo che i beans usino i metodi delle classi, le entity, per realizzare i compiti richiesti.
Protocollo RESTful - le risorse vengono identificate con uno URI, forse sarebbe meglio avere una idea un poì più precisa delle pagine web come indirizzi?*


AccountManager
This bean is responsible for all the operations related to users’ and operators’ accounts.
register: implements the registration process for the users. In particular it creates a new Entity RegisteredUser in the company database, by receiving from the user all the basic information (such as name, surname, address etc.), the chosen email and password and the payment information. 
Returns a confirmation message if the procedure ended well or an error message if the proposed credentials were not valid.
login: implements the login procedure with credentials for both users and operators. It also checks if the credentials of the user are correct and allows the login of the user. 
PINhandling:  manages the process of generating and sending a unique PIN to a registered user.method that creates a unique PIN that can be used by the corresponding user. Two users can’t have the same PIN. send the created PIN to the user via email right after his registration.
suspend:


RegisteredUserManager: 
This bean manages all the features that are available to the users registered to the system: user is able to locate all the available cars, check their battery percentage and reserves one of them; he is also able to check his current reservation, request the unlock of the reserved car and edit his profile.
Possible methods:
findAllAvailableCars(position): this method returns a list of the locations of all the available cars of the company. *L’applicazione poi le visualizzerà su una mappa di Maps?*
getCarPercentage(car): this method returns an integer representing the charge percentage of the selected car’s battery, by calling the related method in the CarManager enterprise bean.
reserveCar(car): if the user has not already an active reservation, this method creates a new Reservation entity and associates it to the user as his active reservation. This method returns a confirmation message if the operation was done correctly or an error message if the operation was not possible.
getAllReservations: this method returns a list of all the reservations created by the user.
Returns a list (eventually empty) of Reservation.
unlockCar: this method handles the unlock of the reserved car if the user is in sufficiently close to the car and if it was inserted the user’s PIN. This method returns a confirmation message or an error message. By using injection this bean will call CarManager, another enterprise bean that communicates to the car using a WebSocket component.


/*Ricordati di inserire nel documento una breve parte in cui parli di Injection e della possibilità di injection of managed beans (tra cui gli EJB e il WebSocket component) grazie al JNDI*/


ReservationManager
This bean manages the features related to the reservation of the user, such as visualizing its basic properties, evaluating the fee of the ride, 
getCurrentReservation: this method shows the user all the information related to his current reservation, such as the starting time and the reserved car. This method returns a Reservation object or an error message communicating that no active reservation exists.
create
terminateReservation:
evaluateFee:






CarManager
This enterprise bean handles all the requests that the system needs to send to the PowerEnjoy cars: by communicating with the WebSocket endpoint in the web server (typically through the managed bean injection feature offered by Java EE) this bean will be able to request any mechanical action of a specified car.
Any modification of a car proprierty will be forwarded to the related entity in the database layer using the Java Persistence API.
Notice that this bean is not directly accessible to the users’ mobile application, and thus it is not implementing the RESTful protocol.
requestUnlock(car Car): this method will send to the WebSocket endpoint in the Web server a request for the unlock of the car: the WebSocket component will forward this request directly to the car and return a boolean outcome of the unlock operation.
setStatus(car Car): this method is used to modify the status of the car passed as parameter, by communicating with the WebSocket endpoint and retrieving the status by the actual car.
setBatteryCharge(car Car): this method is used to update the battery percentage of the car passed as parameter.
getCarPosition:








OperatorManager
This bean provides all the features needed by the operators in order to accomplish their tasks: obtaining a list of all the unavailable cars, the possibility of setting one of the unavailable cars as under miantenance, the ability of setting the fixed car back to an available state.
Possible methods
getAllUnavailableCars: this method collects and returns a list of all the unavailable cars of the company.
setCarStatus: this method is used to set the car status as “under maintenance” when the operator decides to take care of the selected car or when the operator has fixed the car, so that its status is set as “available”.




/*Rivedi dove specificare synchronous o asynchronous response*”






Deployment View


Runtime View


Component Interfaces


Selected Architectural Styles And Patterns


Other Design Decisions
//in the database we won’t store any payment information detail -> Stripe api