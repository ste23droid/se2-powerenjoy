Overview
This section aims to present an overview of the architecture of the PowerEnjoy system, starting from the main software layers (also called abstraction layers or logical components) and their interconnections. 


The software layers can be considered the main high-level components of the PowerEnjoy system. Then the high-level components will be exploded in their sub-components, also by presenting some static and dynamic behavioural views of the system using UML diagrams.


The end of this section will provide information about the main architectural styles and patterns used to design the system and their rationales.


High level components and their interaction
HIGH LEVEL COMPONENTS
The system will be constituted by the following four high-level components (logical layers):


* Database layer: this layer is responsible for storing and retrieving the persistent data of the PowerEnjoy company. It doesn’t implement any business logic and must guarantee the ACID properties during transactions. This layer is accessed through the Application layer.


* Application (Business) layer:  the application layer implements the whole business logic and its algorithms. It is also responsible for the interaction with the cars (management and connection handling) . It interacts with the database layer. Part of the business functionalities can be provided through service-oriented interfaces.


* Web (Presentation) layer: the web layer implements the web presentation layer. This layer can be used partially for the presentation on the mobile application, This layer does not involve any business logic.


*     Client Layer
   * Mobile application: the mobile application used by the users and the operators, which runs on an Android or iOS device. The mobile application communicates directly with the application layer to access the main services offered by the PowerEnjoy system, but also with the web layer to delegate part of the presentation.


   * Car application: Android application running on a car owned by the PowerEnjoy company; it communicates directly with the application layer, since the car application will have its own native UI and there’s no need to interact with the Web Layer for the presentation.




 Layers.png 



This design choice for the logical layers is suitable for the PowerEnjoy system: this design separates well the business logic and the web presentation, allowing more easily the extension of a layer and thus providing an adequate degree of scalability. 


In fact, as stated in the RASD, the architecture should be developed having in mind a future access to the PoweEnjoy services through a web browser and in this case the web presentation layer will become more important. 


The four logical layers identified define a 4-tier architecture. 


The architecture provided is not fully layered, this is mainly due to the interaction with the cars.


All the interactions between the layers can be considered synchronous, except the interaction between the Car Application and the Application layer, which is asynchronous.


TECHNOLOGICAL VIEWPOINT
The Mobile Application will be developed as an application on Android OS and on iOS. 


The Car application will be developed as an application on Android OS.


The Web Layer and the Application Layer will be developed with Java EE7. In particular the vendor implementation chosen is GlassFish.


The Database Layer will be developed using MySQL Server.


The following diagram shows the relations between the high-level components identified and a possible set of technologies to use for the future implementation phase.


 More low_level tiers.png 
[a]


Component View
This section aims to provide more information about the sub-components identified from every high-level component previously mentioned.


Some UML Component diagrams will be provided in order to show the modular decomposition of a component into separate modules and the decoupling of the  architecture in functional areas.


This section will follow a descriptive top-down approach. In designing the component diagrams we have tried to minimize the risks of desynchronization of the different areas of the architecture.
 HighLevel.png 



The Web Layer and the Application layer are included for simplicity in the PowerEnjoy Servers component.


 PowerEnjoyServers.png 



DATABASE LAYER
The database layer uses MySQL Server; for every transactions it must guarantee the ACID properties.
It is interacted from the application layer using the Java Persistence API (JPA) instead of the classic JDBC. JPA provides a convenient shortcut to many of the steps that JDBC has to follow in order to store and retrieve the application data into the DBMS and to make the application layer synchronized with the database layer.
JPA deals with the O/R Mapping and allows to store data by converting the application data objects into persistence entities in the relational database, using annotations in Java classes. It manages the transition of entities from the application layer to the database layer through an API called the EntityManager. The following diagram shows the E/R Model of the PowerEnjoy company.  ER Diagram.png [b]


APPLICATION LAYER


 ApplicationLayerComponent.png 
[c]


The main sub-components of the application layer are implemented using stateless Enterprise JavaBeans (Session Beans).


These sub-components provide the majority of the business logic of the system and are designed to follow the design principles of high cohesion and loose coupling, by offering functionalities strictly related and also by reducing the dependencies between each other. 


A detailed class diagram showing the interactions between the Enterprise JavaBeans implementing the business logic, will be shown later.


Some of these beans implement the RESTful principles and so they offer some external services. The external services provided will be designed to follow the CRUD principles, so that each HTTPS request can be mapped to an appropriate service offered.


AccountManager
This EJB is responsible for all the operations related to users’ and operators’ accounts. This bean is enough self contained so that it could be easily extended in future with other operations related to account management, like: editing of account informations; deletion of a user account; provide a more complex policy to manage the suspension of a user from the PowerEnjoy system.


UserManager
This EJB manages the most used functionalities that are available through the mobile application to the users enrolled to the system. Among these functionalities the most relevant are: locate all the available cars, reserve an available car, request the unlock of a reserved car. This EJB is designed with the principle of flexibility in mind, for example this EJB in future may contain functionalities to retrieve the list of all the reservations made by a user since its registration to the system. [d]


OperatorManager
This EJB provides all the features needed by the operators in order to accomplish their maintenance tasks: obtaining a list of all the unavailable cars; the possibility to set one of the unavailable cars as under maintenance; the possibility to set the fixed car back to an available state.


ReservationManager
This EJB manages the features related to the management of a reservation of a car performed by a user.


Part of the functionalities are exposed by the Application Layer through a RESTful interface, some other functionalities are only local. 


The former are accessed by the user through an interaction with the car application, the latter deal with all the controls necessary to handle properly a reservation, like: understanding when to start counting the reservation time;  evaluate if a reservation can terminate; evaluate if the user can make a stop; evaluate if a reservation has been missed; handle the reservation according to a car failure.


BillingManager
This EJB manages all the functionalities related to the user’s billing, like: the verification of the payment information submitted by the user during the registration procedure; the computation of the user’s bill, discounts and penalties at the end of a ride. In order to accomplish the billing functionalities, this EJB interacts with the BillingService.


CarManager
This EJB handles all the requests that the Application Layer needs to send to the Car Application and also all the consequences of the notification of events that a car forwards to the the Application Layer.


The communication with the car is done through a WebSocket endpoint in the Application Layer (typically through the managed bean injection feature offered by Java EE).


This bean will be able to request any actuation of a command on a specified car.


Any modification of a car property will be forwarded to the related entity bean in the EJB container, and the Java Persistence API will handle the O/R mapping to persist the modification inside the appropriate table in the database.


Notice that this bean is not directly accessible through the users’ mobile application, and thus it is not offering any external interface to the outside world.
 ClassDiagramEJB.png 

 ClassDiagramEntityBeans.png 



WEB LAYER
This layer is responsible to handle presentation functionalities. Among the multiple available web components in Java EE 7 specification (servlets, JSP), we decide to use the framework JSF (JavaServer Faces) because they are designed based on the MVC pattern in order to separate precisely the roles of the View and the Controller. The view can be implemented using static or dynamic HTML web pages, the controller can be implemented using session beans. The model is the core of the PowerEnjoy system and it’s located in the Application Layer.


For the first release of the PowerEnjoy system, we won’t provide a web application accessible completely through a web browser. However this layer will be immediately useful for the Mobile Application, since for some functionalities, like registration, we can use this layer instead of creating twice (Android, iOS) the native UIs. 


This layer is also useful to provide with ease in future, also on Mobile Applications, some “FAQs”, “Q&A”, “Billing Guides” and basic informations about the PowerEnjoy service.


The following is a component diagram exploding the internal of the Web Layer at very high level.
 WebLayerComponent.png 



MOBILE APPLICATION
The Mobile Application will be natively developed using Android SDK and iOS SDK respectively for Android OS and iOS. The language used for the Android Application is Java, the language used for the iOS application is Swift.
In general, for both platforms
we will use the MVC pattern because:


-The distinction between view and controlled is already implicitly present in the SDKs, since layouts, images, assets and media are considered view resources, which get coupled at runtime with the view controllers code.
-The distinction between controllers and model (logic) can be done more easily since we access remote services and we keep all the business logic separately on the Application Layer.


We’ve made a distinction between two types of Controllers:
* View Controllers: controllers responsible to handle view events. This controllers will also deal with the interaction with the MapsService, since the MapsService uses specific views.
* Model Controllers: controllers responsible to:
-interact with the model offered by the Application Layer through external interfaces
-do some necessary elaborations, like parsing the response obtained by the Application Layer.


 MobileApplicationComponent.png 



Some Web Views will be used to offer part of the PowerEnjoy functionalities (like the registration), without having to write them natively on each platform. See Web Layer for more informations.


ANDROID:
-View Controller: we can use Activity from android.support.v7.app.AppCompatActivity. We use the AppCompatActivity to deal more easily with multiple Android OS versions, in order to provide similar experiences to users.
- Model Controller: we can use again android.support.v7.app.AppCompatActivity.
- View: the native UI view layout is defined with image assets and with XML layout files, one for every View Controller. We can use all the UI elements from android.view.View, android.app.Dialog and android.webkit.WebView, like: buttons, pickers, dialogs, switches, web views etc;
-GPS positioning: in order to deal with GPS positioning, we can use the APIs provided by the LocationManager from android.location.LocationManager. Special permissions “ACCESS_COARSE_LOCATION” and “ACCESS_FINE_LOCATION” will be needed in the application manifest file.
-Internet connection: can be used immediately by adding “INTERNET" and “ACCESS_NETWORK_STATE" permissions in the application manifest file.
-MapsService: the MapsService is already part of Android SDK, it should only be configured properly.


iOS
-View Controller: we can use UIViewController.
-Model Controller: for this part we can use custom Swift classes using specific functionalities provided by iOS SDK. 
-View: we can use UIView subclasses, and also UIWebView.
-GPS Positioning: we can use the CoreLocator APIs.
-Internet Connection: we don’t need special permissions to use internet connection.
-Maps Service: can be used by integrating separately the Google Maps SDK for iOS.
 
CAR APPLICATION
The Car Application will be developed with the Android SDK. The whole code will be written using the Java language.


The general concepts about Views and View Controllers are the same as the ones provided for the Android Mobile Application in the previous section, however, there are differences in terms of the interaction with external interfaces and in the communication with the Application Layer.


The Car Controllers are responsible to interact with the car’s hardware and sensors and to manage the network communication with the Application Layer. They also partially interact with the MapsServiceInt for some path discovery and map navigation functionalities.


The network communication between the Car Application and the Application Layer is based on a full-duplex communication channel. The Application Layer plays an active role in this communication, meaning that it can push messages to the Car Application. See rationales.


The Car Application will interact with:
* VehicleInterface: this interface will be used to get informations from the car’s hardware and sensors (like battery SoC) and to actuate commands on the car hardware itself (like locking the car). 
* MapsServiceInt: this interface (or set of interfaces), will be used to interact with Google Maps services, for functionalities like: map visualization; find a feasible path from an origin GPS position to a destination GPS position; car navigation functionalities; visualization of safe areas on the map view etc. 
* CarAppInt: the interface used in the full-duplex network communication with the Application Layer. This communication is based on the WebSocket protocol.                
                 CarApplicationComponent.png 




Deployment View
This section aims to show the topology of the system architecture, by underlining anything that exists in its operational context.


Usually the mapping between tiers and physical machines is not 1:1.
However we have decided to deploy our 4 tiered architecture on 4 different machines. See rationales.


This diagram shows a possible deployment of our artifacts and components on physical machines.


 Deployment.png 
[e]




Runtime View
This section aims to show part of the runtime behaviour of the system through sequence diagrams representing the most significant interactions between components. 


Many interactions have already been shown in the RASD document, using high level sequence diagrams where the PowerEnJoy system was treated like a “black box”. Here, instead, we want to focus more on the internal interactions between components that occur in the PowerEnJoy system.


-pay last ride
-conclude rental and lock
-unlock car
-interaction with google maps api


Component Interfaces


Interface of the application layer to the Client tier
AccountManager:
* register(email, password, personalData[], paymentInformation[]): String
This function allows guests to register to PowerEnJoy. It creates a new user with the information provided as parameters and saves it as an entity in the database of the system. It returns a String representing the outcome of the registration process, that will be displayed on the user’s screen (registration successful or failed).
* login(email, password): String (session identifier  token or Error info)
This function allows an user to log into the PowerEnJoy application using his email and password.It returns a String representing the token that identifies the user during his interaction with the system if the credentials are correct, or an error message displayed on the user’s screen otherwise.
-PINhandler(registeredUserMail): void 
-suspendUser(RegisteredUser): void
-registerOperator(operatorEmail): void (password generata qui dentro, email letta da file di configurazione) 


UserManager
Functions implemented by UserManager:
* findAvailableCarsByGPS(latitude, longitude): List<Car>
This function allows a registered user to find available cars using the GPS  signal of his mobile device (characterized by the attributed latitude and longitude) and to see their info. It returns a list containing all available cars in the city area.
* findAvailableCarsByAddress(address): List<Car>
This function allows a registered user to find available cars using an address in the city and to see their info. It returns a list containing all available cars in the city area.
* reserveCar(CarLicensePlate): String
This function allows a registered user to reserve an available car, identified by its license plate. It also asyncronously enables the verification of the time passed from the reservation, in order to set the car back to available if the user doesn’t unlock it within one hour. It returns a String representing the outcome of the reservation, that is displayed on the user’s screen (reservation successful or failed).
* insertPIN(uniquePIN, latitude, longitude): String
This function allows a registered user to insert his unique PIN code on his mobile device in order to unlock his previously reserved car. It receives the PIN code and the user’s GPS position (latitude and longitude, retrieved through the mobile device’s GPS signal) and checks that the PIN is correct and the user is at most 10m distant to the reserved car. If so, it returns a String containing the message that the PIN insertion was successful, otherwise it will return an error message. Either cases, the message is displayed on the user’s screen.


OperatorManager
Functions implemented by OperatorManager:
* findUnavailableCars(): List<Car> //add a car attribute about problem
This function allows an operator to find all unavailable cars and to see their info and the kind of problem they have. It returns a list containing all unavailable cars in the city area.
* maintainCar(licensePlate): String
This function allows an operator to set as under maintenance an unavailable car, identified by its license plate. It returns a String containing the outcome, that will be displayed on the operator’s screen (successful or unsuccessful, if the operator had another car currently under his maintenance).
* setCarToAvailable(): String
This function allows an operator to set as available a car he maintained. It returns a String containing the outcome, that will be displayed on the operator’s screen (successful or unsuccessful, if the operator did not have any car under his maintenance).


ReservationManager
Functions implemented by ReservationManager:
* terminateReservation(latitude, longitude): String
This function allows a registered user to terminate his resevation by pressing on the button on the car’s screen. It receives as parameter the GPS location of the car (characterized by latitude and longitude). It calls the method evaluateReservationTermination(latitude, longitude); only if this method returns a true value the reservation can actually terminate. It returns a String containing the outcome, that will be displayed on the car’s screen (reservation ended correctly or error message).
* makeStop(latitude, longitude): String
This function allows a registered user to make a stop during his ride by pressing on the button on the car’s screen. It receives as parameter the GPS location of the car (characterized by latitude and longitude). It calls the method evaluateMakeStop(latitude, longitude); only if this method returns a true value the reservation can actually terminate. It returns a String containing the outcome, that will be displayed on the car’s screen (success or error message).
* activateMoneySaving(latitude, longitude, address): String (remote function)
This function allows the registered user to activate the money saving option on the car’s screen. It receives as parameters the current GPS position of the car (characterized by latitude and longitude) and the destination of the user (specified as an address) and it shows on the map the power safe area where to park the car at the end of the ride in order to get a discount. The safe area selected guarantees a uniform distribution of cars in the city and depends on  the available parking slots and on the distance from the user’s destination. It returns a String identyfing the selected safe area, or an error message if no safe area was found respecting the above criteria.
* requestUnlock(): String
This function allows a registered user to unlock a car he previously reserved. It verifies that a reservation for the user that requested the unlock actually exists and that the time passed from the reservation is no more than one hour. If so, it calls the method carUnlock inside CarManager, getting the user’s GPS position from the signal of his mobile device. It also starts a thread that verifies the time passed from the unlocking, so that, if the engine is not ignited within 20 minutes, the method handleCarFailure inside reservationManager is called. It returns a String representing the outcome of the unlocking.
-evaluateReservationTermination(latitude, longitude): boolean //chiamato da terminateReservation, metodo remoto
-evaluateMakeStop(latitude, longitude): boolean //chiamato da makeStop
-evaluateMissedReservation: boolean //chiamato dall’unlock, verifica che non sia missed e in caso fa pagre la fee di 1 euro
-chargeUser()//chiamato da evaluateResTer stoppa il conteggio e chiama il conteggio dei discounts per sapere la cifra finale e poi interagisce con Stripe. 
-notifyUserBill(billInfo) //notifica l’utente del costo dell’ultima ride
-detectCarsSafeArea(safeAreaID): int //chiamato da evaluateResTer per vedere numero di auto in safe area per sapere i posti liberi
-handleCarFailure(): //setta l’auto come unavailable, ferma la reservation e procede con la charge. Metodo chiamato dal CarManager quando riceve una comunicazione di guasto.


BillingManager
-verifyPaymentInformation(paymentInformation[]): String (StripeToken)
-evaluateDiscounts(originalBill, carLicensePlate)
-evaluatePenalties(originalBill, carLicensePlate)
-calculateBill(originalBill, carLicensePlate):String //che arriva da charge user in reservationManager. Restituisce l’esito del pagamento
-evaluatePassengersDiscount(carLicensePlate): boolean // chiama detectPassengers in car manager continuamente finchè la ride non è finita, verifica numero passeggeri e tempo di permanenza


CarManager
This enterprise bean handles all the requests that the system needs to send to the PowerEnjoy cars: by communicating with the WebSocket endpoint in the web server (typically through the managed bean injection feature offered by Java EE) this bean will be able to request any mechanical action of a specified car.
Any modification of a car proprierty will be forwarded to the related entity in the database layer using the Java Persistence API.
Notice that this bean is not directly accessible to the users’ mobile application, and thus it is not implementing the RESTful protocol.
-displayCurrentCharge(carLicensePlate):
-getCarPosition(carLicensePlate): Location
-requestCarLock(carLicensePlate):
-carUnlock(carLicensePlate, userGPSPosition): //chiamato da requestUnlock(carLicensePlate), verifica la distanza tra user e car e se è inferiore a 10 m sblocca l’auto
-detectPassengers(carLicensePlate): int
-handleCarFailureCommunication(carLicensePlate, failureType): //scrive nell’entity il tipo di danno e chiama il corrispettivo metodo in ReservationManager.
 -notifyOnScreen(carLicensePlate, message) // comunica all’auto il message come parametro
-getCarBatteryChargeStatus(carLicensePlate): boolean //charging or not
-getCarBatteryPercentage(carLicensePlate): //un int
-setCarStatus(carLicensePlate, status): //modifica stato auto quando ce n’è bisogno
-getCarStatus(carLicensePlate)
-checksUserOutsideCity(carLicensePlate) //started as soon as the engine ignites, monitors th position in order to verify that the car is inside the city area, otherwise it will notify the user


 Selected Architectural Styles And 
 Patterns
This section aims to list all the architectural styles and patterns applied during the design phase of the system, underlining also the rationales behind the main design decisions. 


ARCHITECTURAL STYLES:
   * Client/Server: if we abstract away some details, our architecture is implementing a Client/Server architecture, even if we don’t have only 2 tiers. This is mainly due to the fact that the most computationally intensive
business logics are located inside the Application (Business) Layer, while the Client Layer has only to deal with presentation functionalities (completely, or partially if it is interacting with the web layer). The client layer is therefore  left “thin” regarding the business logic, while the Application Layer is “fat”.
         This is advantageous for multiple reasons:


        - Avoid platform desynchronization:
The main devices accessing the PowerEnjoy services are mobile devices. The APIs used to develop Android or iOS applications change frequently and this needs to be accounted to guarantee the best possible user experience. If the business logic is located too much on the Client Layer, this may cause desynchronization between the platforms, ending up privileging updates to a platform instead of another.


-Device support flexibility: with a “thin” Client Layer and a “fat” Application Layer it is easier to add support to new client devices, for example web browsers.


-Maintenance: a “fat” Application Layer improves maintenance, since we don’t have to stop the service to update the business logic code.


   * 4-Tier Architecture: the separation of our system in 4 software layers (tiers) can be useful for a number of reasons: 


-Process Flexibility: process flexibility is enhanced since during the implementation phase, each layer can be assigned to different teams of people, which can proceed the development in parallel.


-Device support flexibility: same rationales as in the Client/Server explanation. 


-Maintenance and testing: every software layer can be tested and maintained more or less separately from the others. Therefore it will be  easier to identify and correct eventual bugs.


- Scalability: the number of machines on which a particular layer is deployed can be incremented or decremented based on demand loads and budget.


-Modularity and extendability: since each software layer as a specific functionality to achieve, it is easier to add modules and components to it. 


-Security: if in the future the security of the system becomes a bigger concern, then it will be easier to create multiple DMZ in order to protect more efficiently the business data.


   * Active Server (Server Push: in the HTTP protocol the server is passive and it is able to send data to the client only in response to a client’s request.


In the PowerEnjoy system, though, it is necessary from the Application Layer to request different commands to be actuated on the cars when needed.


The HTTP protocol offers some possible solutions to this issue, such as HTTP polling, by basically putting the client in a situation of periodically sending requests to the server to know if there are some new updates destinated to him.


This technique though is pretty expensive in terms of time and resources, so it seems preferable to use another communication protocol which guarantees a full-duplex communication channel, such as the WebSocket protocol.


In addition, JEE offers the WebSocket APIs for creating and managing easily WebSocket components.


DESIGN PATTERNS:
   * MVC: this design pattern has been followed for both the Mobile Application and the Web Layer. It is well known for the separation of concerns between the roles of model, view and controller.
   * Publisher/Subscriber: this design pattern can be used for the communication between the Application Layer and the Car Applications.


Other Design Decisions
   * BillingService: StripeAPI
We will use Stripe APIs to validate the payment informations provided by the users and to charge the users when needed. The main reason for this choice are:


- Security: by using Stripe APIs we will limit the storage of personal payment information in our database. After checking the payment informations provided by the user through Stripe APIs, Stripe APIs return us a payment token that identifies that payment informations inside their database. We just need to store this token in our database and retrieve it when we will need to charge the user using Stripe APIs.


- Simplicity and Good Documentation: the Stripe APIs are simple to use and very well documented.


The following sample code can be used to charge a user:


// Create a Customer
Map<String, Object> customerParams = new HashMap<String, Object>();
// here we use the payment token retrieved after the validation of the user’s payment information performed by Stripe
customerParams.put("source", token);
customerParams.put("description", "Mario Rossi");

Customer customer = Customer.create(customerParams);

// Charge the Customer
Map<String, Object> chargeParams = new HashMap<String, Object>();
chargeParams.put("amount", 1000); // Amount in cents
chargeParams.put("currency", "eur");
chargeParams.put("customer", customer.getId());

Charge.create(chargeParams);


   * MapsService: Google Maps
We have chosen to use Google Maps APIs to deal with maps visualization; geolocalization on a map; path search; distance calculation between GPS positions. We have made this choice since:
   * Google Maps APIs are the most popular and reliable maps API.
   * Google Maps APIs are easy to use, the APIs provided are wide and very well documented.
   * Google Maps APIs are portable, since Google has released them for all the most used software platforms (Android, iOS, Java platforms included).
   * Google Maps APIs provide a very high availability.


   * VehicleInterface
The VehicleInterface will be used by the Car Application in order to 
interact with the hardware and sensors of the car. Through this interface the Car Application will be able to get informations from the car and also to actuate commands on the car’s hardware, like for example locking/unlocking the car. The cars’ provider from which our customer has bought the cars will provide us a jar library which will contain the above mentioned interface and all the code necessary for that interface to accomplish its tasks.
This library can be included in the Car Application source code during the development.
An example of the VehicleInterface is the following:
getSoC();
getCurrent();
getBatteryStatus();
getVoltage();
getDoorsStatus();
getTrunkDoorStatus();
getDirection();
getSpeed();
getFaults();
getSpecificFaultInformations(fault);
getPassengersNumber();
execCommand(command, params[]);












[a]managed beans?
[b]manca il raggio della safe area
[c]FILL MAPS SERVICE NAME
[d]/*Ricordati di inserire nel documento una breve parte in cui parli di Injection e della possibilità di injection of managed beans (tra cui gli EJB e il WebSocket component) grazie al JNDI*/
[e]da fixare Web container